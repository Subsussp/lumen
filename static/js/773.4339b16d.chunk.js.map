{"version":3,"file":"static/js/773.4339b16d.chunk.js","mappings":"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","sources":["../node_modules/locomotive-scroll/node_modules/lenis/src/maths.js","../node_modules/locomotive-scroll/node_modules/src/animate.ts","../node_modules/locomotive-scroll/node_modules/src/dimensions.ts","../node_modules/locomotive-scroll/node_modules/lenis/src/debounce.js","../node_modules/locomotive-scroll/node_modules/src/emitter.ts","../node_modules/locomotive-scroll/node_modules/src/virtual-scroll.ts","../node_modules/locomotive-scroll/node_modules/src/index.ts","../node_modules/locomotive-scroll/core/IO.ts","../node_modules/locomotive-scroll/utils/maths.ts","../node_modules/locomotive-scroll/core/ScrollElement.ts","../node_modules/locomotive-scroll/core/Core.ts","../node_modules/locomotive-scroll/core/RO.ts","../node_modules/locomotive-scroll/index.ts"],"sourcesContent":["// Clamp a value between a minimum and maximum value\r\nexport function clamp(min, input, max) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n// Truncate a floating-point number to a specified number of decimal places\r\nexport function truncate(value, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\r\nexport function lerp(x, y, t) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\r\nexport function damp(x, y, lambda, dt) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\r\n}\r\n\r\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n// https://anguscroll.com/just/just-modulo\r\nexport function modulo(n, d) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\n\r\n// Animate class to handle value animations with lerping or easing\r\nexport class Animate {\r\n  isRunning: boolean = false\r\n  value: number = 0\r\n  from: number = 0\r\n  to: number = 0\r\n  lerp?: number\r\n  duration?: number = 0\r\n  easing?: Function\r\n  currentTime: number = 0\r\n  onUpdate?: Function\r\n\r\n  // Advance the animation by the given delta time\r\n  advance(deltaTime: number) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  // Stop the animation\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  // Set up the animation from a starting value to an ending value\r\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\r\n  fromTo(\r\n    from: number,\r\n    to: number,\r\n    {\r\n      lerp,\r\n      duration,\r\n      easing,\r\n      onStart,\r\n      onUpdate,\r\n    }: {\r\n      lerp?: number\r\n      duration?: number\r\n      easing?: Function\r\n      onStart?: Function\r\n      onUpdate?: Function\r\n    }\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\ntype DimensionsOptions = {\r\n  wrapper: Window | HTMLElement\r\n  content: HTMLElement\r\n  autoResize?: boolean\r\n  debounce?: number\r\n}\r\n\r\nexport class Dimensions {\r\n  wrapper: Window | HTMLElement\r\n  content: HTMLElement\r\n  width: number = 0\r\n  height: number = 0\r\n  scrollWidth: number = 0\r\n  scrollHeight: number = 0\r\n  debouncedResize?: Function\r\n  wrapperResizeObserver?: ResizeObserver\r\n  contentResizeObserver?: ResizeObserver\r\n\r\n  // @ts-ignore\r\n  constructor({\r\n    wrapper,\r\n    content,\r\n    autoResize = true,\r\n    debounce: debounceValue = 250,\r\n  }: DimensionsOptions = {}) {\r\n    this.wrapper = wrapper\r\n    this.content = content\r\n\r\n    if (autoResize) {\r\n      this.debouncedResize = debounce(this.resize, debounceValue)\r\n\r\n      if (this.wrapper === window) {\r\n        window.addEventListener(\r\n          'resize',\r\n          this.debouncedResize as EventListener,\r\n          false\r\n        )\r\n      } else {\r\n        this.wrapperResizeObserver = new ResizeObserver(\r\n          this.debouncedResize as ResizeObserverCallback\r\n        )\r\n        this.wrapperResizeObserver.observe(this.wrapper as HTMLElement)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(\r\n        this.debouncedResize as ResizeObserverCallback\r\n      )\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n    window.removeEventListener(\r\n      'resize',\r\n      this.debouncedResize as EventListener,\r\n      false\r\n    )\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else if (this.wrapper instanceof HTMLElement) {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.scrollHeight = this.content.scrollHeight\r\n      this.scrollWidth = this.content.scrollWidth\r\n    } else if (this.wrapper instanceof HTMLElement) {\r\n      this.scrollHeight = this.wrapper.scrollHeight\r\n      this.scrollWidth = this.wrapper.scrollWidth\r\n    }\r\n  }\r\n\r\n  get limit(): {\r\n    x: number\r\n    y: number\r\n  } {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","export function debounce(callback, delay) {\r\n  let timer\r\n  return function () {\r\n    let args = arguments\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(function () {\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","export class Emitter {\r\n  events: Record<string, Function[]>\r\n\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  emit(event: string, ...args: any[]) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i](...args)\r\n    }\r\n  }\r\n\r\n  on(event: string, callback: Function) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(callback) || (this.events[event] = [callback])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n    }\r\n  }\r\n\r\n  off(event: string, callback: Function) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\n\r\nexport class VirtualScroll {\r\n  element: HTMLElement | Window\r\n  wheelMultiplier: number\r\n  touchMultiplier: number\r\n  touchStart: {\r\n    x: number | null\r\n    y: number | null\r\n  }\r\n  emitter: Emitter\r\n  lastDelta: {\r\n    x: number\r\n    y: number\r\n  } = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  windowWidth: number = 0\r\n  windowHeight: number = 0\r\n\r\n  constructor(\r\n    element: HTMLElement | Window,\r\n    { wheelMultiplier = 1, touchMultiplier = 1 }\r\n  ) {\r\n    this.element = element\r\n    this.wheelMultiplier = wheelMultiplier\r\n    this.touchMultiplier = touchMultiplier\r\n\r\n    this.touchStart = {\r\n      x: null,\r\n      y: null,\r\n    }\r\n\r\n    this.emitter = new Emitter()\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel as EventListener, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener(\r\n      'touchstart',\r\n      this.onTouchStart as EventListener,\r\n      {\r\n        passive: false,\r\n      }\r\n    )\r\n    this.element.addEventListener(\r\n      'touchmove',\r\n      this.onTouchMove as EventListener,\r\n      {\r\n        passive: false,\r\n      }\r\n    )\r\n    this.element.addEventListener(\r\n      'touchend',\r\n      this.onTouchEnd as EventListener,\r\n      {\r\n        passive: false,\r\n      }\r\n    )\r\n  }\r\n\r\n  // Add an event listener for the given event and callback\r\n  on(event: string, callback: Function) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  // Remove all event listeners and clean up\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel as EventListener)\r\n    this.element.removeEventListener(\r\n      'touchstart',\r\n      this.onTouchStart as EventListener\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchmove',\r\n      this.onTouchMove as EventListener\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchend',\r\n      this.onTouchEnd as EventListener\r\n    )\r\n  }\r\n\r\n  // Event handler for 'touchstart' event\r\n  onTouchStart = (event: TouchEvent) => {\r\n    // @ts-expect-error\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'touchmove' event\r\n  onTouchMove = (event: TouchEvent) => {\r\n    // @ts-expect-error\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - (this.touchStart?.x ?? 0)) * this.touchMultiplier\r\n    const deltaY = -(clientY - (this.touchStart?.y ?? 0)) * this.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event: TouchEvent) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'wheel' event\r\n  onWheel = (event: WheelEvent) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.windowWidth : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.windowHeight : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.wheelMultiplier\r\n    deltaY *= this.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.windowWidth = window.innerWidth\r\n    this.windowHeight = window.innerHeight\r\n  }\r\n}\r\n","import { version } from '../../../package.json'\r\nimport { Animate } from './animate'\r\nimport { Dimensions } from './dimensions'\r\nimport { Emitter } from './emitter'\r\nimport { clamp, modulo } from './maths'\r\nimport { VirtualScroll } from './virtual-scroll'\r\n\r\n// Technical explanation\r\n// - listen to 'wheel' events\r\n// - prevent 'wheel' event to prevent scroll\r\n// - normalize wheel delta\r\n// - add delta to targetScroll\r\n// - animate scroll to targetScroll (smooth context)\r\n// - if animation is not running, listen to 'scroll' events (native context)\r\n\r\ntype Overwrite<T, R> = Omit<T, keyof R> & R\r\n\r\ntype EasingFunction = (t: number) => number\r\ntype Orientation = 'vertical' | 'horizontal'\r\ntype GestureOrientation = 'vertical' | 'horizontal' | 'both'\r\ntype Scrolling = boolean | 'native' | 'smooth'\r\n\r\ntype onVirtualScrollOptions = {\r\n  deltaX: number\r\n  deltaY: number\r\n  event: WheelEvent | TouchEvent\r\n}\r\n\r\nexport type LenisOptions = Partial<{\r\n  wrapper: Window | HTMLElement\r\n  content: HTMLElement\r\n  wheelEventsTarget: Window | HTMLElement\r\n  eventsTarget: Window | HTMLElement\r\n  smoothWheel: boolean\r\n  syncTouch: boolean\r\n  syncTouchLerp: number\r\n  touchInertiaMultiplier: number\r\n  duration: number\r\n  easing: EasingFunction\r\n  lerp: number\r\n  infinite: boolean\r\n  orientation: Orientation\r\n  gestureOrientation: GestureOrientation\r\n  touchMultiplier: number\r\n  wheelMultiplier: number\r\n  autoResize: boolean\r\n  prevent: (node: Element) => boolean\r\n  virtualScroll: (data: onVirtualScrollOptions) => boolean\r\n  __experimental__naiveDimensions: boolean\r\n}>\r\n\r\nexport default class Lenis {\r\n  // __isSmooth: boolean = false // true if scroll should be animated\r\n  __isScrolling: Scrolling = false // true when scroll is animating\r\n  __isStopped: boolean = false // true if user should not be able to scroll - enable/disable programmatically\r\n  __isLocked: boolean = false // same as isStopped but enabled/disabled when scroll reaches target\r\n  __preventNextNativeScrollEvent?: boolean\r\n  __resetVelocityTimeout?: number\r\n\r\n  isTouching?: boolean\r\n  time: number\r\n  userData: Object = {}\r\n  lastVelocity: number = 0\r\n  velocity: number = 0\r\n  direction: 1 | -1 | 0 = 0\r\n  options: Overwrite<\r\n    LenisOptions,\r\n    {\r\n      wrapper: NonNullable<LenisOptions['wrapper']>\r\n    }\r\n  >\r\n  targetScroll: number\r\n  animatedScroll: number\r\n  animate: Animate\r\n  emitter: Emitter\r\n  dimensions: Dimensions\r\n  virtualScroll: VirtualScroll\r\n\r\n  constructor({\r\n    wrapper = window,\r\n    content = document.documentElement,\r\n    wheelEventsTarget = wrapper, // deprecated\r\n    eventsTarget = wheelEventsTarget,\r\n    smoothWheel = true,\r\n    syncTouch = false,\r\n    syncTouchLerp = 0.075,\r\n    touchInertiaMultiplier = 35,\r\n    duration, // in seconds\r\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n    lerp = 0.1,\r\n    infinite = false,\r\n    orientation = 'vertical', // vertical, horizontal\r\n    gestureOrientation = 'vertical', // vertical, horizontal, both\r\n    touchMultiplier = 1,\r\n    wheelMultiplier = 1,\r\n    autoResize = true,\r\n    prevent,\r\n    virtualScroll,\r\n    __experimental__naiveDimensions = false,\r\n  }: LenisOptions = {}) {\r\n    // @ts-expect-error\r\n    window.lenisVersion = version\r\n\r\n    // if wrapper is html or body, fallback to window\r\n    if (\r\n      !wrapper ||\r\n      wrapper === document.documentElement ||\r\n      wrapper === document.body\r\n    ) {\r\n      wrapper = window\r\n    }\r\n\r\n    this.options = {\r\n      wrapper,\r\n      content,\r\n      wheelEventsTarget,\r\n      eventsTarget,\r\n      smoothWheel,\r\n      syncTouch,\r\n      syncTouchLerp,\r\n      touchInertiaMultiplier,\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      infinite,\r\n      gestureOrientation,\r\n      orientation,\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      autoResize,\r\n      prevent,\r\n      virtualScroll,\r\n      __experimental__naiveDimensions,\r\n    } as LenisOptions\r\n\r\n    this.animate = new Animate()\r\n    this.emitter = new Emitter()\r\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\r\n    // this.toggleClassName('lenis', true)\r\n    this.updateClassName()\r\n\r\n    this.userData = {}\r\n    this.time = 0\r\n    this.velocity = this.lastVelocity = 0\r\n    this.isLocked = false\r\n    this.isStopped = false\r\n    // this.hasScrolled = false\r\n    // this.isSmooth = syncTouch || smoothWheel\r\n    // this.isSmooth = false\r\n    this.isScrolling = false\r\n    this.targetScroll = this.animatedScroll = this.actualScroll\r\n\r\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\r\n\r\n    this.options.wrapper.addEventListener(\r\n      'pointerdown',\r\n      this.onPointerDown as EventListener,\r\n      false\r\n    )\r\n\r\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n    })\r\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\r\n  }\r\n\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.options.wrapper.removeEventListener(\r\n      'scroll',\r\n      this.onNativeScroll,\r\n      false\r\n    )\r\n    this.options.wrapper.removeEventListener(\r\n      'pointerdown',\r\n      this.onPointerDown as EventListener,\r\n      false\r\n    )\r\n\r\n    this.virtualScroll.destroy()\r\n    this.dimensions.destroy()\r\n\r\n    this.cleanUpClassName()\r\n\r\n    // this.rootElement.className = ''\r\n\r\n    // this.toggleClassName('lenis', false)\r\n    // this.toggleClassName('lenis-smooth', false)\r\n    // this.toggleClassName('lenis-scrolling', false)\r\n    // this.toggleClassName('lenis-stopped', false)\r\n    // this.toggleClassName('lenis-locked', false)\r\n  }\r\n\r\n  on(event: string, callback: Function) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  off(event: string, callback: Function) {\r\n    return this.emitter.off(event, callback)\r\n  }\r\n\r\n  private setScroll(scroll: number) {\r\n    // apply scroll value immediately\r\n    if (this.isHorizontal) {\r\n      this.rootElement.scrollLeft = scroll\r\n    } else {\r\n      this.rootElement.scrollTop = scroll\r\n    }\r\n  }\r\n\r\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\r\n    if (event.button === 1) {\r\n      this.reset()\r\n    }\r\n  }\r\n\r\n  private onVirtualScroll = (data: onVirtualScrollOptions) => {\r\n    if (\r\n      typeof this.options.virtualScroll === 'function' &&\r\n      this.options.virtualScroll(data) === false\r\n    )\r\n      return\r\n\r\n    const { deltaX, deltaY, event } = data\r\n\r\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\r\n\r\n    // keep zoom feature\r\n    if (event.ctrlKey) return\r\n\r\n    const isTouch = event.type.includes('touch')\r\n    const isWheel = event.type.includes('wheel')\r\n\r\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\r\n    // if (event.type === 'touchend') {\r\n    //   console.log('touchend', this.scroll)\r\n    //   // this.lastVelocity = this.velocity\r\n    //   // this.velocity = 0\r\n    //   // this.isScrolling = false\r\n    //   this.emit({ type: 'touchend' })\r\n    //   // alert('touchend')\r\n    //   return\r\n    // }\r\n\r\n    const isTapToStop =\r\n      this.options.syncTouch &&\r\n      isTouch &&\r\n      event.type === 'touchstart' &&\r\n      !this.isStopped &&\r\n      !this.isLocked\r\n\r\n    if (isTapToStop) {\r\n      this.reset()\r\n      return\r\n    }\r\n\r\n    const isClick = deltaX === 0 && deltaY === 0 // click event\r\n\r\n    // const isPullToRefresh =\r\n    //   this.options.gestureOrientation === 'vertical' &&\r\n    //   this.scroll === 0 &&\r\n    //   !this.options.infinite &&\r\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\r\n\r\n    const isUnknownGesture =\r\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\r\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\r\n\r\n    if (isClick || isUnknownGesture) {\r\n      // console.log('prevent')\r\n      return\r\n    }\r\n\r\n    // catch if scrolling on nested scroll elements\r\n    let composedPath = event.composedPath()\r\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\r\n\r\n    const prevent = this.options.prevent\r\n\r\n    if (\r\n      !!composedPath.find(\r\n        (node) =>\r\n          node instanceof Element &&\r\n          ((typeof prevent === 'function' && prevent?.(node)) ||\r\n            node.hasAttribute?.('data-lenis-prevent') ||\r\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\r\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\r\n            (node.classList?.contains('lenis') &&\r\n              !node.classList?.contains('lenis-stopped'))) // nested lenis instance\r\n      )\r\n    )\r\n      return\r\n\r\n    if (this.isStopped || this.isLocked) {\r\n      event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\r\n      return\r\n    }\r\n\r\n    const isSmooth =\r\n      (this.options.syncTouch && isTouch) ||\r\n      (this.options.smoothWheel && isWheel)\r\n\r\n    if (!isSmooth) {\r\n      this.isScrolling = 'native'\r\n      this.animate.stop()\r\n      return\r\n    }\r\n\r\n    event.preventDefault()\r\n\r\n    let delta = deltaY\r\n    if (this.options.gestureOrientation === 'both') {\r\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\r\n    } else if (this.options.gestureOrientation === 'horizontal') {\r\n      delta = deltaX\r\n    }\r\n\r\n    const syncTouch = isTouch && this.options.syncTouch\r\n    const isTouchEnd = isTouch && event.type === 'touchend'\r\n\r\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5\r\n\r\n    if (hasTouchInertia) {\r\n      delta = this.velocity * this.options.touchInertiaMultiplier\r\n    }\r\n\r\n    this.scrollTo(this.targetScroll + delta, {\r\n      programmatic: false,\r\n      ...(syncTouch\r\n        ? {\r\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\r\n          }\r\n        : {\r\n            lerp: this.options.lerp,\r\n            duration: this.options.duration,\r\n            easing: this.options.easing,\r\n          }),\r\n    })\r\n  }\r\n\r\n  resize() {\r\n    this.dimensions.resize()\r\n  }\r\n\r\n  private emit() {\r\n    this.emitter.emit('scroll', this)\r\n  }\r\n\r\n  private onNativeScroll = () => {\r\n    clearTimeout(this.__resetVelocityTimeout)\r\n    delete this.__resetVelocityTimeout\r\n\r\n    if (this.__preventNextNativeScrollEvent) {\r\n      delete this.__preventNextNativeScrollEvent\r\n      return\r\n    }\r\n\r\n    if (this.isScrolling === false || this.isScrolling === 'native') {\r\n      const lastScroll = this.animatedScroll\r\n      this.animatedScroll = this.targetScroll = this.actualScroll\r\n      this.lastVelocity = this.velocity\r\n      this.velocity = this.animatedScroll - lastScroll\r\n      this.direction = Math.sign(\r\n        this.animatedScroll - lastScroll\r\n      ) as Lenis['direction']\r\n      // this.isSmooth = false\r\n      this.isScrolling = 'native'\r\n      this.emit()\r\n\r\n      if (this.velocity !== 0) {\r\n        this.__resetVelocityTimeout = setTimeout(() => {\r\n          this.lastVelocity = this.velocity\r\n          this.velocity = 0\r\n          this.isScrolling = false\r\n          this.emit()\r\n        }, 400)\r\n      }\r\n\r\n      // this.hasScrolled = true\r\n      // }, 50)\r\n    }\r\n  }\r\n\r\n  private reset() {\r\n    this.isLocked = false\r\n    this.isScrolling = false\r\n    this.animatedScroll = this.targetScroll = this.actualScroll\r\n    this.lastVelocity = this.velocity = 0\r\n    this.animate.stop()\r\n  }\r\n\r\n  start() {\r\n    if (!this.isStopped) return\r\n    this.isStopped = false\r\n\r\n    this.reset()\r\n  }\r\n\r\n  stop() {\r\n    if (this.isStopped) return\r\n    this.isStopped = true\r\n    this.animate.stop()\r\n\r\n    this.reset()\r\n  }\r\n\r\n  raf(time: number) {\r\n    const deltaTime = time - (this.time || time)\r\n    this.time = time\r\n\r\n    this.animate.advance(deltaTime * 0.001)\r\n  }\r\n\r\n  scrollTo(\r\n    target: number | string | HTMLElement,\r\n    {\r\n      offset = 0,\r\n      immediate = false,\r\n      lock = false,\r\n      duration = this.options.duration,\r\n      easing = this.options.easing,\r\n      lerp = this.options.lerp,\r\n      onStart,\r\n      onComplete,\r\n      force = false, // scroll even if stopped\r\n      programmatic = true, // called from outside of the class\r\n      userData = {},\r\n    }: {\r\n      offset?: number\r\n      immediate?: boolean\r\n      lock?: boolean\r\n      duration?: number\r\n      easing?: EasingFunction\r\n      lerp?: number\r\n      onStart?: (lenis: Lenis) => void\r\n      onComplete?: (lenis: Lenis) => void\r\n      force?: boolean\r\n      programmatic?: boolean\r\n      userData?: object\r\n    } = {}\r\n  ) {\r\n    if ((this.isStopped || this.isLocked) && !force) return\r\n\r\n    // keywords\r\n    if (\r\n      typeof target === 'string' &&\r\n      ['top', 'left', 'start'].includes(target)\r\n    ) {\r\n      target = 0\r\n    } else if (\r\n      typeof target === 'string' &&\r\n      ['bottom', 'right', 'end'].includes(target)\r\n    ) {\r\n      target = this.limit\r\n    } else {\r\n      let node\r\n\r\n      if (typeof target === 'string') {\r\n        // CSS selector\r\n        node = document.querySelector(target)\r\n      } else if (target instanceof HTMLElement && target?.nodeType) {\r\n        // Node element\r\n        node = target\r\n      }\r\n\r\n      if (node) {\r\n        if (this.options.wrapper !== window) {\r\n          // nested scroll offset correction\r\n          const wrapperRect = this.rootElement.getBoundingClientRect()\r\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\r\n        }\r\n\r\n        const rect = node.getBoundingClientRect()\r\n\r\n        target =\r\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\r\n      }\r\n    }\r\n\r\n    if (typeof target !== 'number') return\r\n\r\n    target += offset\r\n    target = Math.round(target)\r\n\r\n    if (this.options.infinite) {\r\n      if (programmatic) {\r\n        this.targetScroll = this.animatedScroll = this.scroll\r\n      }\r\n    } else {\r\n      target = clamp(0, target, this.limit)\r\n    }\r\n\r\n    if (target === this.targetScroll) return\r\n\r\n    this.userData = userData\r\n\r\n    if (immediate) {\r\n      this.animatedScroll = this.targetScroll = target\r\n      this.setScroll(this.scroll)\r\n      this.reset()\r\n      this.preventNextNativeScrollEvent()\r\n      this.emit()\r\n      onComplete?.(this)\r\n      this.userData = {}\r\n      return\r\n    }\r\n\r\n    if (!programmatic) {\r\n      this.targetScroll = target\r\n    }\r\n\r\n    this.animate.fromTo(this.animatedScroll, target, {\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      onStart: () => {\r\n        // started\r\n        if (lock) this.isLocked = true\r\n        this.isScrolling = 'smooth'\r\n        onStart?.(this)\r\n      },\r\n      onUpdate: (value: number, completed: boolean) => {\r\n        this.isScrolling = 'smooth'\r\n\r\n        // updated\r\n        this.lastVelocity = this.velocity\r\n        this.velocity = value - this.animatedScroll\r\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\r\n\r\n        this.animatedScroll = value\r\n        this.setScroll(this.scroll)\r\n\r\n        if (programmatic) {\r\n          // wheel during programmatic should stop it\r\n          this.targetScroll = value\r\n        }\r\n\r\n        if (!completed) this.emit()\r\n\r\n        if (completed) {\r\n          this.reset()\r\n          this.emit()\r\n          onComplete?.(this)\r\n          this.userData = {}\r\n\r\n          // avoid emitting event twice\r\n          this.preventNextNativeScrollEvent()\r\n        }\r\n      },\r\n    })\r\n  }\r\n\r\n  private preventNextNativeScrollEvent() {\r\n    this.__preventNextNativeScrollEvent = true\r\n\r\n    requestAnimationFrame(() => {\r\n      delete this.__preventNextNativeScrollEvent\r\n    })\r\n  }\r\n\r\n  get rootElement() {\r\n    return (\r\n      this.options.wrapper === window\r\n        ? document.documentElement\r\n        : this.options.wrapper\r\n    ) as HTMLElement\r\n  }\r\n\r\n  get limit() {\r\n    if (this.options.__experimental__naiveDimensions) {\r\n      if (this.isHorizontal) {\r\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\r\n      } else {\r\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\r\n      }\r\n    } else {\r\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\r\n    }\r\n  }\r\n\r\n  get isHorizontal() {\r\n    return this.options.orientation === 'horizontal'\r\n  }\r\n\r\n  get actualScroll(): number {\r\n    // value browser takes into account\r\n    return this.isHorizontal\r\n      ? this.rootElement.scrollLeft\r\n      : this.rootElement.scrollTop\r\n  }\r\n\r\n  get scroll(): number {\r\n    return this.options.infinite\r\n      ? modulo(this.animatedScroll, this.limit)\r\n      : this.animatedScroll\r\n  }\r\n\r\n  get progress(): number {\r\n    // avoid progress to be NaN\r\n    return this.limit === 0 ? 1 : this.scroll / this.limit\r\n  }\r\n\r\n  // get isSmooth() {\r\n  //   return this.__isSmooth\r\n  // }\r\n\r\n  // private set isSmooth(value: boolean) {\r\n  //   if (this.__isSmooth !== value) {\r\n  //     this.__isSmooth = value\r\n  //     this.updateClassName()\r\n  //   }\r\n  // }\r\n\r\n  get isScrolling() {\r\n    return this.__isScrolling\r\n  }\r\n\r\n  private set isScrolling(value: Scrolling) {\r\n    if (this.__isScrolling !== value) {\r\n      this.__isScrolling = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isStopped() {\r\n    return this.__isStopped\r\n  }\r\n\r\n  private set isStopped(value: boolean) {\r\n    if (this.__isStopped !== value) {\r\n      this.__isStopped = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isLocked() {\r\n    return this.__isLocked\r\n  }\r\n\r\n  private set isLocked(value: boolean) {\r\n    if (this.__isLocked !== value) {\r\n      this.__isLocked = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isSmooth() {\r\n    return this.isScrolling === 'smooth'\r\n  }\r\n\r\n  get className() {\r\n    let className = 'lenis'\r\n    if (this.isStopped) className += ' lenis-stopped'\r\n    if (this.isLocked) className += ' lenis-locked'\r\n    if (this.isScrolling) className += ' lenis-scrolling'\r\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\r\n    // if (this.isScrolling === 'native') className += ' lenis-native'\r\n    // if (this.isSmooth) className += ' lenis-smooth'\r\n    return className\r\n  }\r\n\r\n  private updateClassName() {\r\n    this.cleanUpClassName()\r\n\r\n    this.rootElement.className =\r\n      `${this.rootElement.className} ${this.className}`.trim()\r\n  }\r\n\r\n  private cleanUpClassName() {\r\n    this.rootElement.className = this.rootElement.className\r\n      .replace(/lenis(-\\w+)?/g, '')\r\n      .trim()\r\n  }\r\n}\r\n","/**\n * Intersection Observer\n *\n * Detecting visibility of an element in the viewport.\n *\n * Features functions to:\n *\n * - Trigger inview/outOfView callbacks\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\n *\n * References:\n *\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\n */\n\nimport type { IIOOptions } from '../types';\nimport ScrollElement from './ScrollElement';\n\nexport default class IO {\n    public scrollElements: ScrollElement[];\n    private rootMargin: string;\n    private IORaf: boolean;\n    private observer!: IntersectionObserver;\n\n    constructor({\n        scrollElements,\n        rootMargin = '-1px -1px -1px -1px',\n        IORaf,\n    }: IIOOptions) {\n        // Parameters\n        this.scrollElements = scrollElements;\n        this.rootMargin = rootMargin;\n        this.IORaf = IORaf;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize Intersection Observer.\n     *\n     * @private\n     */\n    private _init() {\n        // Options\n        const observerOptions = {\n            rootMargin: this.rootMargin,\n        };\n\n        // Callback\n        const onIntersect = (entries: IntersectionObserverEntry[]) => {\n            entries.forEach((entry) => {\n                const $targetItem: ScrollElement | undefined =\n                    this.scrollElements.find(\n                        (item) => item.$el === entry.target\n                    );\n\n                if (entry.isIntersecting) {\n                    $targetItem && ($targetItem.isAlreadyIntersected = true);\n                    this._setInview(entry);\n                } else if ($targetItem && $targetItem.isAlreadyIntersected) {\n                    this._setOutOfView(entry);\n                }\n            });\n        };\n\n        // Instance\n        this.observer = new IntersectionObserver(onIntersect, observerOptions);\n\n        // Observe each default elements\n        for (const scrollElement of this.scrollElements) {\n            const $scrollElement = scrollElement.$el;\n            this.observe($scrollElement);\n        }\n    }\n\n    /**\n     * Lifecyle - Destroy Intersection Observer.\n     */\n    public destroy() {\n        this.observer.disconnect();\n    }\n\n    /**\n     * Subscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to observe.\n     */\n    public observe($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.observe($scrollElement);\n    }\n\n    /**\n     * Unsubscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\n     */\n    public unobserve($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.unobserve($scrollElement);\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger inview callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setInview(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOn();\n        !this.IORaf && scrollElement?.setInview();\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger out of view callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setOutOfView(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOff();\n        !this.IORaf && scrollElement?.setOutOfView();\n\n        // Unobserve if element doesn't have repeat attribute\n        if (!scrollElement?.attributes.scrollRepeat && !this.IORaf) {\n            this.unobserve(entry.target as HTMLElement);\n        }\n    }\n}\n","// https://greensock.com/docs/v3/GSAP/gsap.utils\n\n/**\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\n *\n * @param {number} min   - Minimum value expected.\n * @param {number} max   - Maximum value expected.\n * @param {number} value - Current value.\n *\n * @returns {number} - Clamped value.\n */\nexport function clamp(min: number, max: number, value: number): number {\n    return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\n *\n * @param {number} inMin  - Current minimum value.\n * @param {number} inMax  - Current maximum value.\n * @param {number} outMin - Maximum value expected.\n * @param {number} outMax - Maximum value expected.\n * @param {number} value  - Current value.\n *\n * @returns {number} - New value that should be between minimum value expected and maximum value.\n */\nexport function mapRange(\n    inMin: number,\n    inMax: number,\n    outMin: number,\n    outMax: number,\n    value: number\n): number {\n    const inRange = inMax - inMin;\n    const outRange = outMax - outMin;\n    return outMin + (((value - inMin) / inRange) * outRange || 0);\n}\n\n/**\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\n *\n * @param {number} min   - Current minimum value.\n * @param {number} max   - Current maximum value.\n * @param {number} value - Current value.\n *\n * @returns {number} - New value that should be between 0 and 1.\n */\nexport function normalize(min: number, max: number, value: number): number {\n    return mapRange(min, max, 0, 1, value);\n}\n\n/**\n * Get closest number from an array.\n *\n * @param {number[]} array  - Numbers array.\n * @param {number}   target - Reference value.\n *\n * @returns {number} - Closest number.\n */\nexport function closestNumber(array: number[], target: number): number {\n    return array.reduce((prev, curr) => {\n        return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\n    });\n}\n","/**\n * Scroll Element\n *\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\n *\n * Features functions to:\n *\n * - scrollClass - Add a custom class when the element is intersected by the offset\n * - scrollOffset - Determine offsets to intersect the element\n * - scrollPosition - Determine the element positions to consider an element as intersected.\n * - scrollModuleProgress - Send scroll progress to modular module that have a specific method (PROGRESS_MODULAR_METHOD)\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\n * - scrollEventProgress - Send scroll progress to custom event listeners.\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\n * - scrollCall - Call a custom event or a modular callback when the element is intersected\n */\n\nimport type {\n    IModular,\n    IScrollElementOptions,\n    IScrollElementAttributes,\n    IScrollElementIntersection,\n    IScrollElementMetrics,\n    IProgressModularModules,\n    IScrollElementCallbacksValues,\n    scrollCallWay,\n    scrollCallFrom,\n    scrollOrientation,\n} from '../types';\nimport { clamp, closestNumber, normalize, mapRange } from '../utils/maths';\n\n/** Constants */\nconst INVIEW_CLASS = 'is-inview';\nconst PROGRESS_CSS_VAR = '--progress';\nconst PROGRESS_MODULAR_METHOD = 'onScrollProgress';\n\nexport default class ScrollElement {\n    public $el: HTMLElement;\n    public id: number;\n    public needRaf: boolean;\n    public attributes: IScrollElementAttributes;\n    public scrollOrientation: scrollOrientation;\n    public isAlreadyIntersected: boolean;\n\n    private intersection: IScrollElementIntersection;\n    private metrics: IScrollElementMetrics;\n    private currentScroll: number;\n    private translateValue: number;\n    private progress: number;\n    private lastProgress: number | null;\n    private modularInstance?: IModular;\n    private progressModularModules: IProgressModularModules[];\n    private isInview: boolean;\n    private isInteractive: boolean;\n    private isInFold: boolean;\n    private isFirstResize: boolean;\n\n    private subscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n    private unsubscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n\n    constructor({\n        $el,\n        id,\n        modularInstance,\n        subscribeElementUpdateFn,\n        unsubscribeElementUpdateFn,\n        needRaf,\n        scrollOrientation,\n    }: IScrollElementOptions) {\n        // Scroll DOM element\n        this.$el = $el;\n        // Unique ID\n        this.id = id;\n        // RAF option\n        this.needRaf = needRaf;\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n        // Modular.js\n        this.modularInstance = modularInstance;\n        // Parent's callbacks\n        this.subscribeElementUpdateFn = subscribeElementUpdateFn;\n        this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\n\n        // Attributes\n        this.attributes = {\n            scrollClass: this.$el.dataset['scrollClass'] ?? INVIEW_CLASS,\n            scrollOffset: this.$el.dataset['scrollOffset'] ?? '0,0',\n            scrollPosition: this.$el.dataset['scrollPosition'] ?? 'start,end',\n            scrollModuleProgress:\n                this.$el.dataset['scrollModuleProgress'] != null,\n            scrollCssProgress: this.$el.dataset['scrollCssProgress'] != null,\n            scrollEventProgress:\n                this.$el.dataset['scrollEventProgress'] ?? null,\n            scrollSpeed:\n                this.$el.dataset['scrollSpeed'] != null\n                    ? parseFloat(this.$el.dataset['scrollSpeed'])\n                    : null,\n            scrollRepeat: this.$el.dataset['scrollRepeat'] != null,\n            scrollCall: this.$el.dataset['scrollCall'] ?? null,\n            scrollCallSelf: this.$el.dataset['scrollCallSelf'] != null,\n            scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] != null,\n            scrollEnableTouchSpeed:\n                this.$el.dataset['scrollEnableTouchSpeed'] != null,\n        };\n\n        // Limits\n        this.intersection = {\n            start: 0,\n            end: 0,\n        };\n\n        // Metrics\n        this.metrics = {\n            offsetStart: 0,\n            offsetEnd: 0,\n            bcr: {} as DOMRect,\n        };\n\n        // Scroll Values\n        this.currentScroll =\n            this.scrollOrientation === 'vertical'\n                ? window.scrollY\n                : window.scrollX;\n\n        // Parallax\n        this.translateValue = 0;\n\n        // Progress\n        this.progress = 0;\n        this.lastProgress = null;\n        this.progressModularModules = [];\n\n        // Inview\n        this.isInview = false;\n        this.isInteractive = false;\n        this.isAlreadyIntersected = false;\n        this.isInFold = false;\n        this.isFirstResize = true;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize progress tracking.\n     *\n     * @private\n     */\n    private _init() {\n        if (!this.needRaf) {\n            return;\n        }\n\n        // Prepare modules progress\n        if (this.modularInstance && this.attributes.scrollModuleProgress) {\n            this._getProgressModularModules();\n        }\n\n        // First resize to compute all values\n        this._resize();\n    }\n\n    /**\n     * Callback - Resize callback\n     */\n    public onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        this.currentScroll = currentScroll;\n        this._resize();\n    }\n\n    /**\n     * Callback - RAF callback\n     */\n    public onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        const wSize =\n            this.scrollOrientation === 'vertical'\n                ? window.innerHeight\n                : window.innerWidth;\n        this.currentScroll = currentScroll;\n        this._computeProgress();\n\n        // Parallax\n        if (\n            this.attributes.scrollSpeed &&\n            !isNaN(this.attributes.scrollSpeed)\n        ) {\n            // if touch detected or smooth disabled\n            if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\n                if (this.translateValue) {\n                    this.$el.style.transform = `translate3d(0, 0, 0)`;\n                }\n                this.translateValue = 0;\n\n                // if mousewheel or smooth enabled\n            } else {\n                // Check fold condition\n                if (this.isInFold) {\n                    const progress = Math.max(0, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                } else {\n                    const progress = mapRange(0, 1, -1, 1, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                }\n\n                this.$el.style.transform =\n                    this.scrollOrientation === 'vertical'\n                        ? `translate3d(0, ${this.translateValue}px, 0)`\n                        : `translate3d(${this.translateValue}px, 0, 0)`;\n            }\n        }\n    }\n\n    /**\n     * Inview callback\n     */\n    public setInview() {\n        if (this.isInview) {\n            return;\n        }\n\n        this.isInview = true;\n        this.$el.classList.add(this.attributes.scrollClass);\n\n        const way: scrollCallWay = 'enter';\n        const from: scrollCallFrom = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Out of view callback\n     */\n    public setOutOfView() {\n        if (!(this.isInview && this.attributes.scrollRepeat)) {\n            return;\n        }\n\n        this.isInview = false;\n        this.$el.classList.remove(this.attributes.scrollClass);\n\n        const way: scrollCallWay = 'leave';\n        const from: scrollCallFrom = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Switch interactivity on to subscribe the instance to the RAF\n     * and start calculations.\n     */\n    public setInteractivityOn() {\n        if (this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = true;\n        this.subscribeElementUpdateFn(this);\n    }\n\n    /**\n     * Switch interactivity off to unsubscribe the instance to the RAF\n     * and stop calculations.\n     */\n    public setInteractivityOff() {\n        if (!this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = false;\n        this.unsubscribeElementUpdateFn(this);\n\n        // Force progress to progress limit when the element is out\n        this.lastProgress != null &&\n            this._computeProgress(closestNumber([0, 1], this.lastProgress));\n    }\n\n    /**\n     * Resize method that compute the element's values.\n     *\n     * @private\n     */\n    private _resize() {\n        this.metrics.bcr = this.$el.getBoundingClientRect();\n        this._computeMetrics();\n        this._computeIntersection();\n\n        // First resize logic\n        if (this.isFirstResize) {\n            this.isFirstResize = false;\n            // Dispatch default call if the element is in fold.\n            if (this.isInFold) {\n                this.setInview();\n            }\n        }\n    }\n\n    /**\n     * Compute element's offsets and determine if the element is in fold.\n     *\n     * @private\n     */\n    private _computeMetrics() {\n        const { top, left, height, width } = this.metrics.bcr;\n        const wSize =\n            this.scrollOrientation === 'vertical'\n                ? window.innerHeight\n                : window.innerWidth;\n        const metricsStart = this.scrollOrientation === 'vertical' ? top : left;\n        const metricsSize =\n            this.scrollOrientation === 'vertical' ? height : width;\n\n        this.metrics.offsetStart =\n            this.currentScroll + metricsStart - this.translateValue;\n        this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\n\n        if (\n            this.metrics.offsetStart < wSize &&\n            !this.attributes.scrollIgnoreFold\n        ) {\n            this.isInFold = true;\n        } else {\n            this.isInFold = false;\n        }\n    }\n\n    /**\n     * Compute intersection values depending on the context.\n     *\n     * @private\n     */\n    private _computeIntersection() {\n        // Window size\n        const wSize =\n            this.scrollOrientation === 'vertical'\n                ? window.innerHeight\n                : window.innerWidth;\n\n        // Metrics size\n        const metricsSize =\n            this.scrollOrientation === 'vertical'\n                ? this.metrics.bcr.height\n                : this.metrics.bcr.width;\n\n        // Offset\n        const offset = this.attributes.scrollOffset.split(',');\n        const offsetStart = offset[0] != undefined ? offset[0].trim() : '0';\n        const offsetEnd = offset[1] != undefined ? offset[1].trim() : '0';\n\n        // Positions\n        const scrollPosition = this.attributes.scrollPosition.split(',');\n        let scrollPositionStart =\n            scrollPosition[0] != undefined ? scrollPosition[0].trim() : 'start';\n        const scrollPositionEnd =\n            scrollPosition[1] != undefined ? scrollPosition[1].trim() : 'end';\n\n        // Viewport\n        const viewportStart = offsetStart.includes('%')\n            ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01\n            : parseInt(offsetStart);\n        const viewportEnd = offsetEnd.includes('%')\n            ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01\n            : parseInt(offsetEnd);\n\n        // Fold exception\n        if (this.isInFold) {\n            scrollPositionStart = 'fold';\n        }\n\n        // Define Intersection Start\n        switch (scrollPositionStart) {\n            case 'start':\n                this.intersection.start =\n                    this.metrics.offsetStart - wSize + viewportStart;\n                break;\n\n            case 'middle':\n                this.intersection.start =\n                    this.metrics.offsetStart -\n                    wSize +\n                    viewportStart +\n                    metricsSize * 0.5;\n                break;\n\n            case 'end':\n                this.intersection.start =\n                    this.metrics.offsetStart -\n                    wSize +\n                    viewportStart +\n                    metricsSize;\n                break;\n\n            case 'fold':\n                this.intersection.start = 0;\n                break;\n\n            default:\n                this.intersection.start =\n                    this.metrics.offsetStart - wSize + viewportStart;\n                break;\n        }\n\n        // Define Intersection End\n        switch (scrollPositionEnd) {\n            case 'start':\n                this.intersection.end = this.metrics.offsetStart - viewportEnd;\n                break;\n\n            case 'middle':\n                this.intersection.end =\n                    this.metrics.offsetStart - viewportEnd + metricsSize * 0.5;\n                break;\n\n            case 'end':\n                this.intersection.end =\n                    this.metrics.offsetStart - viewportEnd + metricsSize;\n                break;\n\n            default:\n                this.intersection.end =\n                    this.metrics.offsetStart - viewportEnd + metricsSize;\n                break;\n        }\n\n        // Avoid to have the end < the start intersection >\n        if (this.intersection.end <= this.intersection.start) {\n            switch (scrollPositionEnd) {\n                case 'start':\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n\n                case 'middle':\n                    this.intersection.end =\n                        this.intersection.start + metricsSize * 0.5;\n                    break;\n\n                case 'end':\n                    this.intersection.end =\n                        this.intersection.start + metricsSize;\n                    break;\n\n                default:\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Compute the scroll progress of the element depending\n     * on its intersection values.\n     *\n     * @private\n     *\n     * @param {number} [forcedProgress] - Value to force progress.\n     */\n    private _computeProgress(forcedProgress?: number) {\n        // Progress\n        const progress =\n            forcedProgress ??\n            clamp(\n                0,\n                1,\n                normalize(\n                    this.intersection.start,\n                    this.intersection.end,\n                    this.currentScroll\n                )\n            );\n\n        this.progress = progress;\n\n        if (progress != this.lastProgress) {\n            this.lastProgress = progress;\n\n            // Set the element's progress to the css variable\n            this.attributes.scrollCssProgress && this._setCssProgress(progress);\n\n            // Set the element's progress to the custom event listeners\n            this.attributes.scrollEventProgress &&\n                this._setCustomEventProgress(progress);\n\n            // Set the element's progress to inline modules\n            if (this.attributes.scrollModuleProgress) {\n                for (const modularModules of this.progressModularModules) {\n                    this.modularInstance &&\n                        this.modularInstance.call(\n                            PROGRESS_MODULAR_METHOD,\n                            progress,\n                            modularModules.moduleName,\n                            modularModules.moduleId\n                        );\n                }\n            }\n\n            // Logic to trigger the inview/out of view callbacks\n            progress > 0 && progress < 1 && this.setInview();\n            progress === 0 && this.setOutOfView();\n            progress === 1 && this.setOutOfView();\n        }\n    }\n\n    /**\n     * Set the element's progress to a specific css variable.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCssProgress(currentProgress = 0) {\n        this.$el.style.setProperty(\n            PROGRESS_CSS_VAR,\n            currentProgress.toString()\n        );\n    }\n\n    /**\n     * Set the element's progress to the custom event listeners.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCustomEventProgress(currentProgress = 0) {\n        const customEventName = this.attributes.scrollEventProgress;\n\n        if (!customEventName) return;\n\n        const customEvent = new CustomEvent(customEventName, {\n            detail: {\n                target: this.$el,\n                progress: currentProgress,\n            },\n        });\n        window.dispatchEvent(customEvent);\n    }\n\n    /**\n     * Get modular modules that can listen the element's progress.\n     *\n     * @private\n     */\n    _getProgressModularModules() {\n        if (!this.modularInstance) {\n            return;\n        }\n\n        const modulesIdNames = Object.keys(this.$el.dataset).filter((key) =>\n            key.includes('module')\n        );\n        const modules: any[] = Object.entries(this.modularInstance.modules);\n\n        if (!modulesIdNames.length) {\n            return;\n        }\n\n        for (const modulesIdName of modulesIdNames) {\n            const moduleId = this.$el.dataset[modulesIdName];\n\n            if (!moduleId) {\n                return;\n            }\n\n            for (const module of modules) {\n                const [moduleName, moduleObj] = module;\n\n                if (moduleId in moduleObj) {\n                    this.progressModularModules.push({\n                        moduleName,\n                        moduleId,\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Function to get scroll call from.\n     *\n     * @private\n     */\n    _getScrollCallFrom(): scrollCallFrom {\n        const closestIntersectionValue = closestNumber(\n            [this.intersection.start, this.intersection.end],\n            this.currentScroll\n        );\n        return this.intersection.start === closestIntersectionValue\n            ? 'start'\n            : 'end';\n    }\n\n    /**\n     * Function to dispatch a custom event or call a modular callback.\n     *\n     * @private\n     *\n     * @param {scrollCallWay} way - Enter or leave.\n     * @param {scrollCallFrom} from - Start or end.\n     */\n    _dispatchCall(way: scrollCallWay, from: scrollCallFrom) {\n        const callParameters = this.attributes.scrollCall?.split(',');\n        const callSelf = this.attributes?.scrollCallSelf;\n\n        if (callParameters && callParameters.length > 1) {\n            // Using Modular.js (https://github.com/modularorg/modularjs)\n            const [func, moduleName, moduleId] = callParameters;\n            let targetModuleId;\n\n            // If the module is set on the scroll element\n            if (callSelf) {\n                targetModuleId = this.$el.dataset[`module${moduleName.trim()}`];\n            } else {\n                targetModuleId = moduleId;\n            }\n\n            this.modularInstance &&\n                this.modularInstance.call(\n                    func.trim(),\n                    {\n                        target: this.$el,\n                        way,\n                        from,\n                    },\n                    moduleName.trim(),\n                    targetModuleId?.trim()\n                );\n        } else if (callParameters) {\n            // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n            const [customEventName] = callParameters;\n            const customEvent = new CustomEvent(customEventName, {\n                detail: {\n                    target: this.$el,\n                    way,\n                    from,\n                },\n            });\n            window.dispatchEvent(customEvent);\n        }\n    }\n}\n","/**\n * Integrates Lenis with Locomotive's built-in animation system\n */\n\nimport type {\n    CoreOptions,\n    IModular,\n    IScrollElementCallbacksValues,\n    scrollOrientation,\n} from '../types';\nimport IO from './IO';\nimport ScrollElement from './ScrollElement';\n\n/** Defined attributes that need a requestAnimationFrame */\nconst ATTRIBUTES_THAT_NEED_RAF = [\n    'scrollOffset',\n    'scrollPosition',\n    'scrollModuleProgress',\n    'scrollCssProgress',\n    'scrollEventProgress',\n    'scrollSpeed',\n];\n\n/** Default root margins */\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\n\nexport default class Core {\n    private $scrollContainer!: HTMLElement;\n    private modularInstance?: IModular;\n    private triggerRootMargin!: string;\n    private rafRootMargin!: string;\n    private scrollElements!: ScrollElement[];\n    private triggeredScrollElements!: ScrollElement[];\n    private RAFScrollElements!: ScrollElement[];\n    private scrollElementsToUpdate!: ScrollElement[];\n    private IOTriggerInstance!: IO;\n    private IORafInstance!: IO;\n    private scrollOrientation!: scrollOrientation;\n\n    constructor({\n        $el,\n        modularInstance,\n        triggerRootMargin,\n        rafRootMargin,\n        scrollOrientation,\n    }: CoreOptions) {\n        if (!$el) {\n            console.error('Please provide a DOM Element as scrollContainer');\n            return;\n        }\n\n        // Scroll container\n        this.$scrollContainer = $el;\n\n        // Modular.js\n        this.modularInstance = modularInstance;\n\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n\n        // IO Margins\n        this.triggerRootMargin = triggerRootMargin ?? TRIGGER_ROOT_MARGIN;\n        this.rafRootMargin = rafRootMargin ?? RAF_ROOT_MARGIN;\n\n        // ScrollElements arrays\n        this.scrollElements = [];\n        this.triggeredScrollElements = [];\n        this.RAFScrollElements = [];\n        this.scrollElementsToUpdate = [];\n\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize the core.\n     *\n     * @private\n     */\n    private _init() {\n        const $scrollElements =\n            this.$scrollContainer.querySelectorAll('[data-scroll]');\n\n        const $scrollElementsArr = Array.from($scrollElements) as HTMLElement[]\n        this._subscribeScrollElements($scrollElementsArr);\n\n        // Trigger IO\n        this.IOTriggerInstance = new IO({\n            scrollElements: [...this.triggeredScrollElements],\n            rootMargin: this.triggerRootMargin,\n            IORaf: false,\n        });\n\n        // Raf IO\n        this.IORafInstance = new IO({\n            scrollElements: [...this.RAFScrollElements],\n            rootMargin: this.rafRootMargin,\n            IORaf: true,\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy core.\n     */\n    public destroy() {\n        this.IOTriggerInstance.destroy();\n        this.IORafInstance.destroy();\n        this._unsubscribeAllScrollElements();\n    }\n\n    /**\n     * Callback - Resize callback.\n     */\n    onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.RAFScrollElements) {\n            scrollElement.onResize({\n                currentScroll,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Callback - RAF callback.\n     */\n    onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.scrollElementsToUpdate) {\n            scrollElement.onRender({\n                currentScroll,\n                smooth,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Remove items from lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\n     */\n    removeScrollElements($oldContainer: HTMLElement) {\n        const $scrollElementsToRemove =\n            $oldContainer.querySelectorAll('[data-scroll]');\n\n        if (!$scrollElementsToRemove.length) return;\n\n        // 1. Remove from IO\n        for (let index = 0; index < this.triggeredScrollElements.length; index++) {\n            const scrollElement = this.triggeredScrollElements[index];\n            const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove) as HTMLElement []\n            if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n                this.IOTriggerInstance.unobserve(scrollElement.$el);\n                this.triggeredScrollElements.splice(index, 1);\n            }\n        }\n\n        for (let index = 0; index < this.RAFScrollElements.length; index++) {\n            const scrollElement = this.RAFScrollElements[index];\n            const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove) as HTMLElement []\n            if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n                this.IORafInstance.unobserve(scrollElement.$el);\n                this.RAFScrollElements.splice(index, 1);\n            }\n        }\n\n        // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\n        $scrollElementsToRemove.forEach(($scrollElement) => {\n            const targetScrollElementToUpdate =\n                this.scrollElementsToUpdate.find(\n                    (scrollElement) => scrollElement.$el === $scrollElement\n                );\n            const targetScrollElement = this.scrollElements.find(\n                (scrollElement) => scrollElement.$el === $scrollElement\n            );\n\n            if (targetScrollElementToUpdate) {\n                this._unsubscribeElementUpdate(targetScrollElementToUpdate);\n            }\n            if (targetScrollElement) {\n                this.scrollElements = this.scrollElements.filter(\n                    (scrollElementItem) =>\n                        scrollElementItem.id != targetScrollElement.id\n                );\n            }\n        });\n    }\n\n    /**\n     * Add items to lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\n     */\n    addScrollElements($newContainer: HTMLElement) {\n        // 3. Rebuild ScrollElements\n        const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\n\n        // 4. Get max scrollElement.id\n        const ids: number[] = [];\n        this.scrollElements.forEach((scrollElement) => {\n            ids.push(scrollElement.id);\n        });\n        const maxID = Math.max(...ids, 0);\n        const fromIndex = maxID + 1;\n        const $scrollElementsArr = Array.from($scrollElements) as HTMLElement[]\n        this._subscribeScrollElements(\n            $scrollElementsArr,\n            fromIndex,\n            true\n        );\n    }\n\n    /**\n     * Create a ScrollElement instance for each elements with\n     * `data-scroll` attribute.\n     *\n     * @private\n     *\n     * @param {HTMLElement[]} $scrollElements - List of elements that need\n     *     to be regarded.\n     */\n    _subscribeScrollElements(\n        $scrollElements: HTMLElement[],\n        fromIndex = 0,\n        toObserve = false\n    ) {\n        // For each scroll element create a ScrollElement instance\n        for (let index = 0; index < $scrollElements.length; index++) {\n            const $scrollElement = $scrollElements[index];\n            const needRaf = this._checkRafNeeded($scrollElement);\n\n            const scrollElementInstance = new ScrollElement({\n                $el: $scrollElement,\n                id: fromIndex + index,\n                scrollOrientation: this.scrollOrientation,\n                modularInstance: this.modularInstance,\n                subscribeElementUpdateFn:\n                    this._subscribeElementUpdate.bind(this),\n                unsubscribeElementUpdateFn:\n                    this._unsubscribeElementUpdate.bind(this),\n                needRaf,\n            });\n\n            // Push to common array\n            this.scrollElements.push(scrollElementInstance);\n\n            // Push to specific array\n            if (needRaf) {\n                this.RAFScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IORafInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IORafInstance.observe(scrollElementInstance.$el);\n                }\n            } else {\n                this.triggeredScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IOTriggerInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IOTriggerInstance.observe(scrollElementInstance.$el);\n                }\n            }\n        }\n    }\n\n    /**\n     * Clear all ScrollElement arrays.\n     *\n     * @private\n     */\n    _unsubscribeAllScrollElements() {\n        this.scrollElements = [];\n        this.RAFScrollElements = [];\n        this.triggeredScrollElements = [];\n        this.scrollElementsToUpdate = [];\n    }\n\n    /**\n     * Subscribe ScrollElement instance that needs to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - ScrollElement instance inview\n     *     that needs to be updated.\n     */\n    _subscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate.push(scrollElement);\n    }\n\n    /**\n     * Unscribe ScrollElement instance that doesn't need to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - The updated ScrollElement instance\n     *     out of view now.\n     */\n    _unsubscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(\n            (scrollElementToUpdate) =>\n                scrollElementToUpdate.id != scrollElement.id\n        );\n    }\n\n    /**\n     * Check if a DOM Element need a requestAnimationFrame to be used.\n     *\n     * @private\n     *\n     * @param {HTMLElement} $scrollElement - The element that needs to be checked.\n     *\n     * @returns {boolean}\n     */\n    _checkRafNeeded($scrollElement: HTMLElement) {\n        let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\n\n        // Remove utils\n        const removeAttribute = (attributeToRemove: string) => {\n            attributesThatNeedRaf = attributesThatNeedRaf.filter(\n                (attribute) => attribute != attributeToRemove\n            );\n        };\n\n        // 1. Check scroll offset values\n        if ($scrollElement.dataset.scrollOffset) {\n            const value = $scrollElement.dataset.scrollOffset\n                .split(',')\n                .map((test) => test.replace('%', '').trim())\n                .join(',');\n            if (value != '0,0') {\n                return true;\n            } else {\n                removeAttribute('scrollOffset');\n            }\n        } else {\n            removeAttribute('scrollOffset');\n        }\n\n        // 2. Check scroll position values\n        if ($scrollElement.dataset.scrollPosition) {\n            const value = $scrollElement.dataset.scrollPosition.trim();\n            if (value != 'top,bottom') {\n                return true;\n            } else {\n                removeAttribute('scrollPosition');\n            }\n        } else {\n            removeAttribute('scrollPosition');\n        }\n\n        // 3. Check scroll speed values\n        if (\n            $scrollElement.dataset.scrollSpeed &&\n            !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))\n        ) {\n            return true;\n        } else {\n            removeAttribute('scrollSpeed');\n        }\n\n        // 4. Check others attributes\n        for (const attribute of attributesThatNeedRaf) {\n            if (attribute in $scrollElement.dataset) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","/**\n * Resize Observer\n *\n * The Resize Observer API provides a performant mechanism by which code can monitor an element for changes to its size,\n * with notifications being delivered to the observer each time the size changes.\n *\n * Features functions to:\n *\n * - Trigger the resize callback if the specified element's size change.\n *\n * References:\n *\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Resize_Observer_API}\n */\n\nimport type { IROOptions } from '../types';\n\nexport default class RO {\n    private $resizeElements: HTMLElement[];\n    private isFirstObserve: boolean;\n    private observer!: ResizeObserver;\n    private resizeCallback: () => void;\n\n    constructor({ resizeElements, resizeCallback = () => {} }: IROOptions) {\n        // Parameters\n        this.$resizeElements = resizeElements;\n        this.resizeCallback = resizeCallback;\n\n        // Flags\n        this.isFirstObserve = true;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize Resize Observer.\n     *\n     * @private\n     */\n    private _init() {\n        // Callback\n        const onResize = (entries: ResizeObserverEntry[]) => {\n            !this.isFirstObserve && this.resizeCallback?.();\n            this.isFirstObserve = false;\n        };\n\n        // Instance\n        this.observer = new ResizeObserver(onResize);\n\n        // Observe each default elements\n        for (const $resizeElement of this.$resizeElements) {\n            this.observer.observe($resizeElement);\n        }\n    }\n\n    /**\n     * Lifecyle - Destroy Resize Observer.\n     */\n    public destroy() {\n        this.observer.disconnect();\n    }\n}\n","//@ts-ignore\nimport Lenis from 'lenis';\nimport Core from './core/Core';\nimport RO from './core/RO';\nimport type {\n    ILenisScrollToOptions,\n    ILenisScrollValues,\n    ILocomotiveScrollOptions,\n    IModular,\n    lenisTargetScrollTo,\n} from './types';\nimport type { LenisOptions } from 'lenis';\n\n/**\n * Locomotive Scroll\n *\n * Detection of elements in viewport & smooth scrolling with parallax.\n *\n * Inspired by\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\n * and built around\n * {@link https://github.com/darkroomengineering/lenis lenis.js}.\n */\n\nexport default class LocomotiveScroll {\n    public rafPlaying: boolean;\n    public lenisInstance: any;\n\n    private coreInstance: any;\n\n    private lenisOptions?: LenisOptions;\n    private modularInstance?: IModular;\n    private triggerRootMargin?: string;\n    private rafRootMargin?: string;\n    private rafInstance?: any;\n    private autoResize?: boolean;\n    private autoStart?: boolean;\n    private ROInstance?: RO;\n    private scrollCallback?(scrollValues: ILenisScrollValues): void;\n    private initCustomTicker?: (render: () => void) => void;\n    private destroyCustomTicker?: (render: () => void) => void;\n    private _onRenderBind: () => void;\n    private _onResizeBind: () => void;\n    private _onScrollToBind: (event: MouseEvent) => void;\n\n    constructor({\n        lenisOptions = {},\n        modularInstance,\n        triggerRootMargin,\n        rafRootMargin,\n        autoResize = true,\n        autoStart = true,\n        scrollCallback = () => {},\n        initCustomTicker,\n        destroyCustomTicker,\n    }: ILocomotiveScrollOptions = {}) {\n\n        for (const [key] of Object.entries(lenisOptions)) {\n            if ([\"wrapper\", \"content\", \"infinite\"].includes(key)) {\n                console.warn(`Warning: Key \"${key}\" is not possible to edit in Locomotive Scroll.`);\n            }\n        }\n\n        // Get arguments\n        Object.assign(this, {\n            lenisOptions,\n            modularInstance,\n            triggerRootMargin,\n            rafRootMargin,\n            autoResize,\n            autoStart,\n            scrollCallback,\n            initCustomTicker,\n            destroyCustomTicker,\n        });\n\n\n        // Binding\n        this._onRenderBind = this._onRender.bind(this);\n        this._onScrollToBind = this._onScrollTo.bind(this);\n        this._onResizeBind = this._onResize.bind(this);\n\n        // Data\n        this.rafPlaying = false;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize instance.\n     *\n     * @private\n     */\n    private _init(): void {\n        // Create Lenis instance\n        this.lenisInstance = new Lenis({\n            ...this.lenisOptions,\n            wrapper: window,\n            content: document.documentElement,\n            infinite: false\n        });\n        this.lenisInstance?.on('scroll', this.scrollCallback);\n\n        // Add scroll direction attribute on body\n        document.documentElement.setAttribute(\n            'data-scroll-orientation',\n            this.lenisInstance.options.orientation\n        );\n\n        requestAnimationFrame(() => {\n            // Create Core Instance\n            this.coreInstance = new Core({\n                $el: this.lenisInstance.rootElement,\n                modularInstance: this.modularInstance,\n                triggerRootMargin: this.triggerRootMargin,\n                rafRootMargin: this.rafRootMargin,\n                scrollOrientation: this.lenisInstance.options.orientation,\n            });\n\n            // Bind Events\n            this._bindEvents();\n\n            // RAF warning\n            if (this.initCustomTicker && !this.destroyCustomTicker) {\n                console.warn(\n                    'initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            } else if (!this.initCustomTicker && this.destroyCustomTicker) {\n                console.warn(\n                    'destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            }\n\n            // Start RAF\n            this.autoStart && this.start();\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy instance.\n     */\n    public destroy(): void {\n        // Stop raf\n        this.stop();\n        // Unbind Events\n        this._unbindEvents();\n        // Destroy Lenis\n        this.lenisInstance.destroy();\n        // Destroy Core\n        this.coreInstance?.destroy();\n\n        // Ensure a delay before destroying to handle cases of instant destruction\n        requestAnimationFrame(() => {\n            this.coreInstance?.destroy();\n        });\n    }\n\n    /**\n     * Events - Subscribe events to listen.\n     */\n    private _bindEvents() {\n        this._bindScrollToEvents();\n\n        if (this.autoResize) {\n            if ('ResizeObserver' in window) {\n                this.ROInstance = new RO({\n                    resizeElements: [document.body],\n                    resizeCallback: this._onResizeBind,\n                });\n            } else {\n                (window as any).addEventListener('resize', this._onResizeBind);\n            }\n        }\n    }\n\n    /**\n     * Events - Unsubscribe listened events.\n     */\n    private _unbindEvents() {\n        this._unbindScrollToEvents();\n\n        if (this.autoResize) {\n            if ('ResizeObserver' in window) {\n                this.ROInstance && this.ROInstance.destroy();\n            } else {\n                (window as any).removeEventListener(\n                    'resize',\n                    this._onResizeBind\n                );\n            }\n        }\n    }\n\n    /**\n     * Events - Subscribe scrollTo events to listen.\n     */\n    private _bindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el: HTMLElement): void => {\n                $el.addEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Events - Unsubscribe scrollTo listened events.\n     */\n    private _unbindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el: HTMLElement) => {\n                $el.removeEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Callback - Resize callback.\n     */\n    private _onResize() {\n        // Waiting the next frame to get the new current scroll value return by Lenis\n        requestAnimationFrame(() => {\n            this.coreInstance?.onResize({\n                currentScroll: this.lenisInstance.scroll,\n            });\n        });\n    }\n\n    /**\n     * Callback - Render callback.\n     */\n    private _onRender() {\n        this.lenisInstance?.raf(Date.now());\n\n        this.coreInstance?.onRender({\n            currentScroll: this.lenisInstance.scroll,\n            smooth: this.lenisInstance.options.smoothWheel,\n        });\n    }\n\n    /**\n     * Callback - Scroll To callback.\n     */\n    private _onScrollTo(event: MouseEvent) {\n        event.preventDefault();\n        const $target = (event.currentTarget as HTMLElement) ?? null;\n        if (!$target) return;\n        const target =\n            $target.getAttribute('data-scroll-to-href') ||\n            $target.getAttribute('href');\n        const offset = $target.getAttribute('data-scroll-to-offset') || 0;\n        const duration =\n            $target.getAttribute('data-scroll-to-duration') ||\n            this.lenisInstance.options.duration\n        target &&\n            this.scrollTo(target, {\n                offset: typeof offset === 'string' ? parseInt(offset) : offset,\n                duration:\n                    typeof duration === 'string'\n                        ? parseInt(duration)\n                        : duration,\n            });\n    }\n\n    /**\n     * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public start(): void {\n        if (this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis start method\n        this.lenisInstance?.start();\n\n        this.rafPlaying = true;\n        this.initCustomTicker\n            ? this.initCustomTicker(this._onRenderBind)\n            : this._raf();\n    }\n\n    /**\n     * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public stop(): void {\n        if (!this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis stop method\n        this.lenisInstance?.stop();\n\n        this.rafPlaying = false;\n        this.destroyCustomTicker\n            ? this.destroyCustomTicker(this._onRenderBind)\n            : this.rafInstance && cancelAnimationFrame(this.rafInstance);\n    }\n\n    /**\n     * Remove old scroll elements items and rebuild ScrollElements instances.\n     */\n    public removeScrollElements($oldContainer: HTMLElement): void {\n        if (!$oldContainer) {\n            console.error('Please provide a DOM Element as $oldContainer');\n            return;\n        }\n\n        this._unbindScrollToEvents($oldContainer);\n        this.coreInstance?.removeScrollElements($oldContainer);\n    }\n\n    /**\n     * Add new scroll elements items and rebuild ScrollElements instances.\n     */\n    public addScrollElements($newContainer: HTMLElement): void {\n        if (!$newContainer) {\n            console.error('Please provide a DOM Element as $newContainer');\n            return;\n        }\n\n        this.coreInstance?.addScrollElements($newContainer);\n        requestAnimationFrame(() => {\n            this._bindScrollToEvents($newContainer);\n        });\n    }\n\n    /**\n     * Trigger resize callback.\n     */\n    public resize(): void {\n        this._onResizeBind();\n    }\n\n    /**\n     * Trigger scroll to callback.\n     */\n    public scrollTo(\n        target: lenisTargetScrollTo,\n        options?: ILenisScrollToOptions\n    ): void {\n        this.lenisInstance?.scrollTo(target, {\n            offset: options?.offset,\n            lerp: options?.lerp,\n            duration: options?.duration,\n            immediate: options?.immediate,\n            lock: options?.lock,\n            force: options?.force,\n            easing: options?.easing,\n            onComplete: options?.onComplete,\n        });\n    }\n\n    /**\n     * RequestAnimationFrame that active Lenis smooth and scroll progress.\n     *\n     * @private\n     *\n     */\n    private _raf() {\n        this._onRenderBind();\n        this.rafInstance = requestAnimationFrame(() => this._raf());\n    }\n}\n\nexport * from './types';\n"],"names":["clamp","t","i","e","Math","max","min","Animate","constructor","isRunning","value","from","to","duration","currentTime","advance","this","easing","s","lerp","exp","round","stop","onUpdate","call","fromTo","_ref","o","onStart","n","l","Dimensions","wrapper","content","autoResize","debounce","arguments","length","undefined","width","height","scrollWidth","scrollHeight","resize","onWrapperResize","onContentResize","window","innerWidth","innerHeight","HTMLElement","clientWidth","clientHeight","debouncedResize","clearTimeout","setTimeout","apply","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","disconnect","removeEventListener","limit","x","y","Emitter","events","emit","_len","Array","_key","on","push","filter","off","VirtualScroll","_ref2","wheelMultiplier","touchMultiplier","lastDelta","windowWidth","windowHeight","onTouchStart","clientX","clientY","targetTouches","touchStart","emitter","deltaX","deltaY","event","onTouchMove","r","h","onTouchEnd","onWheel","deltaMode","onWindowResize","element","passive","Lenis","document","documentElement","wheelEventsTarget","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaMultiplier","a","pow","c","infinite","d","orientation","u","gestureOrientation","p","m","v","g","prevent","w","virtualScroll","S","__experimental__naiveDimensions","f","__isScrolling","__isStopped","__isLocked","userData","lastVelocity","velocity","direction","onPointerDown","button","reset","onVirtualScroll","options","ctrlKey","type","includes","isTouching","isStopped","isLocked","composedPath","slice","indexOf","rootElement","find","Element","hasAttribute","classList","contains","preventDefault","isScrolling","animate","abs","scrollTo","targetScroll","Object","assign","programmatic","onNativeScroll","__resetVelocityTimeout","__preventNextNativeScrollEvent","animatedScroll","actualScroll","sign","lenisVersion","body","dimensions","updateClassName","time","cleanUpClassName","setScroll","isHorizontal","scrollLeft","scrollTop","start","raf","offset","immediate","lock","onComplete","force","querySelector","nodeType","getBoundingClientRect","left","top","scroll","preventNextNativeScrollEvent","requestAnimationFrame","progress","isSmooth","className","concat","trim","replace","scrollElements","rootMargin","IORaf","observer","_init","IntersectionObserver","forEach","$el","target","isIntersecting","isAlreadyIntersected","_setInview","_setOutOfView","unobserve","setInteractivityOn","setInview","setInteractivityOff","setOutOfView","attributes","scrollRepeat","reduce","id","modularInstance","subscribeElementUpdateFn","unsubscribeElementUpdateFn","needRaf","scrollOrientation","intersection","metrics","currentScroll","translateValue","lastProgress","progressModularModules","isInview","isInteractive","isInFold","isFirstResize","scrollClass","dataset","scrollOffset","scrollPosition","scrollModuleProgress","scrollCssProgress","scrollEventProgress","scrollSpeed","parseFloat","scrollCall","scrollCallSelf","scrollIgnoreFold","scrollEnableTouchSpeed","end","offsetStart","offsetEnd","bcr","scrollY","scrollX","_getProgressModularModules","_resize","onResize","_ref3","onRender","_ref4","smooth","_computeProgress","isNaN","style","transform","add","_getScrollCallFrom","_dispatchCall","remove","_computeMetrics","_computeIntersection","split","parseInt","_setCssProgress","_setCustomEventProgress","moduleName","moduleId","setProperty","toString","CustomEvent","detail","dispatchEvent","keys","entries","modules","way","_ref5","triggerRootMargin","rafRootMargin","$scrollContainer","triggeredScrollElements","RAFScrollElements","scrollElementsToUpdate","IOTriggerInstance","IORafInstance","console","error","querySelectorAll","_subscribeScrollElements","_unsubscribeAllScrollElements","_ref6","_ref7","removeScrollElements","splice","_unsubscribeElementUpdate","addScrollElements","_checkRafNeeded","_subscribeElementUpdate","bind","map","join","_ref8","resizeElements","resizeCallback","$resizeElements","isFirstObserve","lenisOptions","autoStart","scrollCallback","initCustomTicker","destroyCustomTicker","rafPlaying","lenisInstance","coreInstance","rafInstance","ROInstance","_onRenderBind","_onResizeBind","_onScrollToBind","warn","_onRender","_onScrollTo","_onResize","setAttribute","_bindEvents","_unbindEvents","_bindScrollToEvents","_unbindScrollToEvents","Date","now","currentTarget","getAttribute","_raf","cancelAnimationFrame"],"sourceRoot":""}